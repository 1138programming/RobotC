#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button,         sensorTouch)
#pragma config(Sensor, dgtl2,  encoder,        sensorQuadEncoder)
#pragma config(Sensor, dgtl12, LED,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           TestMotor,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float rps = 0;
bool buttonPressed = false;
int iterations = 5;
float rpsReadings[5] = {0, 0, 0, 0, 0};

void average() {
	rps = 0;
	for(int a = 0; a < 5; a++)
		rps += rpsReadings[a];
	rps /= 5;
}

task main()
{
	clearTimer(T1);
	while(true)
	{
		//Sets a boolean to one if the button is pressed or zero if it is not pressed
		if(SensorValue[button] == 1)
			buttonPressed = true;
		else
			buttonPressed = false;

		//If boolean "buttonPressed" is true, the motor starts, the integer "iterations" is set to zero, the timer is cleared, and the boolean is set to false. If boolean "buttonPressed" is false and the integer "iterations" is greater than or equal to 4, the motor is stopped and the timer is cleared again.
		if(buttonPressed)
		{
			iterations = 0;
			motor[TestMotor] = 127;
			clearTimer(T1);
			buttonPressed = false;
			SensorValue(encoder) = 0;
		}	else if(!buttonPressed && iterations >= 5) {
			motor[TestMotor] = 0;
			buttonPressed = false;
			if(iterations == 5)
				average();
			iterations = 6;
		}

		if(time1[T1] >= 1000 && iterations < 5)
		{
			rpsReadings[iterations] = SensorValue[encoder];
			iterations++;
			clearTimer(T1);
			SensorValue(encoder) = 0;
		}
	}
}
