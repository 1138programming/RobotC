#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button,         sensorTouch)
#pragma config(Sensor, dgtl2,  encoder,        sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  LED4,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  LED3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, LED2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LED,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           TestMotor,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool tested = false;
float rps = 0;
bool buttonPressed = false;
int iterations = 5;
float rpsReadings[5] = {0, 0, 0, 0, 0};
string type = "";
string IME = "";

void average() {
	rps = 0;
	for(int a = 0; a < 5; a++)
		rps += abs(rpsReadings[a]);
	rps /= 5;
}

//void flashLight() {
//	if(round((time1[T2] + 500) / 300) == ((time1[T2] + 500) / 300)) {
//		if(type == "torque") {
//			turnLEDOn(dgtl1);
//			wait10Msec(1);
//			turnLEDOff(dgtl1);
//			if(time1[T2] >= 1100)
//				clearTimer(T2);
//		} else if(type == "speead")
//	}
//}

task main()
{
	clearTimer(T1);
	clearTimer(T2);
	resetMotorEncoder(port1);
	while(true)
	{
		//Sets a boolean to one if the button is pressed or zero if it is not pressed
		if(SensorValue[button] == 1)
			buttonPressed = true;
		else
			buttonPressed = false;

		//If boolean "buttonPressed" is true, the motor starts, the integer "iterations" is set to zero, the timer is cleared, and the boolean is set to false. If boolean "buttonPressed" is false and the integer "iterations" is greater than or equal to 4, the motor is stopped and the timer is cleared again.
		if(buttonPressed)
		{
			iterations = 0;
			motor[TestMotor] = 127;
			clearTimer(T1);
			buttonPressed = false;
			SensorValue(encoder) = 0;
			}	else if(!buttonPressed && iterations >= 5) {
			motor[TestMotor] = 0;
			buttonPressed = false;
			if(iterations == 5)
				average();
			iterations = 6;
		}

		if(time1[T1] >= 1000 && iterations < 5)
		{
			rpsReadings[iterations] = SensorValue[encoder];
			iterations++;
			clearTimer(T1);
			SensorValue(encoder) = 0;
		}

		if(rps > 0 && rps <= 799)
			type = "Torque";
		else if(rps >= 800 & rps <= 1199)
			type = "Speed";
		else if(rps >= 1200)
			type = "Turbo";
		else
			type = "NA";
	
	if(getMotorEncoder(port1) > 0)
	{	
		IME = "Encoder";
	}
	else
	{
		IME = "No encoder";	
	}
		clearLCDLine(0);                      
  	clearLCDLine(1);
  	displayLCDPos(0, 0);
		displayNextLCDString(type);
		displayLCDPos(1, 0);
		displayNextLCDString(IME);	
	}
}
