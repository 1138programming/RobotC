#pragma config(Sensor, dgtl4,  myEncoderR,     sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  myEncoderL,     sensorQuadEncoder)
#pragma config(Motor,  port6,           shooter1,      tmotorVex393_MC29, openLoop)//LEFT
#pragma config(Motor,  port7,           shooter2,      tmotorVex393_MC29, openLoop)//LEFT
#pragma config(Motor,  port8,           shooter3,      tmotorVex393_MC29, openLoop)//RIGHT
#pragma config(Motor,  port9,           shooter4,      tmotorVex393_MC29, openLoop)//RIGHT
#pragma config(Motor,  port10,          collector,     tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// PID using optical shaft encoder

//
// Shaft encoder has 360 pulses per revolution
//
/*START Left Flywheel PID Definitions*/
#define PID_SENSOR_INDEXL    myEncoderL
#define PID_SENSOR_SCALEL    1

#define PID_MOTOR_INDEXL1     shooter3
#define PID_MOTOR_INDEXL2     shooter4

#define PID_MOTOR_SCALEL     -1 //Determines which way the left flywheel spins
/*END Left Flywheel PID Definitions*/

/*START Right Flywheel PID Definitions*/
#define PID_SENSOR_INDEXR    myEncoderR
#define PID_SENSOR_SCALER    1

#define PID_MOTOR_INDEXR1     shooter1
#define PID_MOTOR_INDEXR2     shooter2

#define PID_MOTOR_SCALER     1 //Determines which way the right flywheel spins

/*END Right Flywheel PID Definitions*/

#define PID_DRIVE_MAX       127
#define PID_DRIVE_MIN     (-127)

#define PID_INTEGRAL_LIMIT  50

// These could be constants but leaving them
// as variables allows them to be modified in the debugger while the program is running
float  pid_KpL = 0.37;
float  pid_KiL = 0.005;
float  pid_KdL = 0.01;
int lPrevious = 0;
int MotorPowerL = 0;
int MotorSpeedL = 0;
float  pid_KpR = 0.37;
float  pid_KiR = 0.005;
float  pid_KdR = 0.01;
int rPrevious = 0;
int MotorPowerR = 0;
int MotorSpeedR = 0;

static int   pidRunning = 0;
static float pidRequestedValue;
static float pidDelta;



/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  pid control task                                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
task pidControllerL() //Sample program found on forums modified for Team 83 Robot
{
	float  pidSensorCurrentValueL;
	float  pidErrorL;
	float  pidLastErrorL;
	float  pidIntegralL;
	float  pidDerivativeL;
	float  pidDriveL;

	// If we are using an encoder then clear it
	if( SensorType[ PID_SENSOR_INDEXL ] == sensorQuadEncoder )
		SensorValue[ PID_SENSOR_INDEXL ] = 0;

	// Initialize the variables
	pidLastErrorL  = 0;
	pidIntegralL   = 0;

	while( true )
	{
		// Is PID control active ?
		if( pidRunning > 0 )
		{
			// Read the sensor value and scale
			pidSensorCurrentValueL = SensorValue[ PID_SENSOR_INDEXL ] * PID_SENSOR_SCALEL;

			// calculate error
			pidErrorL = pidSensorCurrentValueL - pidRequestedValue;

			// integral - if Ki is not 0
			if( pid_KiL != 0 )
			{
				// Makes sure the integral doesn't get too large and causes the flywheel to overshoot
				if( abs(pidErrorL) < PID_INTEGRAL_LIMIT )
					pidIntegralL = pidIntegralL + pidErrorL;
				else
					pidIntegralL = 0;
			}
			else
				pidIntegralL = 0;

			// calculate the derivative
			pidDerivativeL = pidErrorL - pidLastErrorL;
			pidLastErrorL  = pidErrorL;

			// calculate drive
			pidDriveL = (pid_KpL * pidErrorL) + (pid_KiL * pidIntegralL) + (pid_KdL * pidDerivativeL);

			// limit drive
			if( pidDriveL > PID_DRIVE_MAX )
				pidDriveL = PID_DRIVE_MAX;
			if( pidDriveL < PID_DRIVE_MIN )
				pidDriveL = PID_DRIVE_MIN;

			// This code controls the actual motors motor
			motor[ PID_MOTOR_INDEXL1 ] = pidDriveL * PID_MOTOR_SCALEL;
			motor[ PID_MOTOR_INDEXL2 ] = pidDriveL * PID_MOTOR_SCALEL;
			//Variable used for debugging purposes
			MotorPowerL = pidDriveL * PID_MOTOR_SCALEL;
		}
		else
		{
			// clear all
			pidErrorL      = 0;
			pidLastErrorL  = 0;
			pidIntegralL   = 0;
			pidDerivativeL = 0;
			motor[ PID_MOTOR_INDEXL1 ] = 0;
			motor[ PID_MOTOR_INDEXL2 ] = 0;
			SensorValue[ PID_SENSOR_INDEXL ] = 0;
		}

		wait1Msec( 25 );
	}
}

task pidControllerR()
{
	float  pidSensorCurrentValueR;

	float  pidErrorR;
	float  pidLastErrorR;
	float  pidIntegralR;
	float  pidDerivativeR;
	float  pidDriveR;

	// If we are using an encoder then clear it
	if( SensorType[ PID_SENSOR_INDEXR ] == sensorQuadEncoder )
		SensorValue[ PID_SENSOR_INDEXR ] = 0;

	// Init the variables
	pidLastErrorR  = 0;
	pidIntegralR   = 0;

	while( true )
	{
		// Is PID control active ?
		if( pidRunning > 0 )
		{
			// Read the sensor value and scale
			pidSensorCurrentValueR = SensorValue[ PID_SENSOR_INDEXR ] * PID_SENSOR_SCALER;

			// calculate error
			pidErrorR = pidSensorCurrentValueR - pidRequestedValue;

			// integral - if Ki is not 0
			if( pid_KiR != 0 )
			{
				// Makes sure the integral doesn't get too large and causes the flywheel to overshoot
				if( abs(pidErrorR) < PID_INTEGRAL_LIMIT )
					pidIntegralR = pidIntegralR + pidErrorR;
				else
					pidIntegralR = 0;
			}
			else
				pidIntegralR = 0;

			// calculate the derivative
			pidDerivativeR = pidErrorR - pidLastErrorR;
			pidLastErrorR  = pidErrorR;

			// calculate drive
			pidDriveR = (pid_KpR * pidErrorR) + (pid_KiR * pidIntegralR) + (pid_KdR * pidDerivativeR);

			// limit drive
			if( pidDriveR > PID_DRIVE_MAX )
				pidDriveR = PID_DRIVE_MAX;
			if( pidDriveR < PID_DRIVE_MIN )
				pidDriveR = PID_DRIVE_MIN;

			// This code controls the motors
			motor[ PID_MOTOR_INDEXR1 ] = pidDriveR * PID_MOTOR_SCALER;
			motor[ PID_MOTOR_INDEXR2 ] = pidDriveR * PID_MOTOR_SCALER;
			//Variable used for debugging purposes
			MotorPowerR = pidDriveR * PID_MOTOR_SCALER;
		}
		else
		{
			// clear all
			pidErrorR      = 0;
			pidLastErrorR  = 0;
			pidIntegralR   = 0;
			pidDerivativeR = 0;
			motor[ PID_MOTOR_INDEXR1 ] = 0;
			motor[ PID_MOTOR_INDEXR2 ] = 0;
			SensorValue[ PID_SENSOR_INDEXR ] = 0;
		}

		wait1Msec( 25 );
	}
}
