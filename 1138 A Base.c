#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  clawRightPiston, sensorDigitalOut)
#pragma config(Sensor, dgtl2,  clawLeftPiston, sensorDigitalOut)
#pragma config(Sensor, dgtl3,  hookRightPiston, sensorDigitalOut)
#pragma config(Sensor, dgtl4,  hookLeftPiston, sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,            ,             tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightFrontMotor, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port3,           rightBackMotor, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_6)
#pragma config(Motor,  port4,           shooterRightTop, tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port5,           shooterRightBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           shooterLeftTop, tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           shooterLeftBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftFrontMotor, tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port9,           leftBackMotor, tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float joy1X = vexRT[Ch4];
float joy1Y = vexRT[Ch3];
float joy2X = vexRT[Ch1];
float joy2Y = vexRT[Ch2];
float angle = 0;
float radius = 0;
float targetAngle = 0;
float turn = 0;

void shooter(int power) {
	motor[shooterRightTop] = power;
	motor[shooterRightBottom] = power;
	motor[shooterLeftTop] = power;
	motor[shooterLeftBottom] = power;
}

void claw(bool right, int left) {
	SensorValue[clawRightPiston] = right ? 1 : 0;
	SensorValue[clawLeftPiston] = left ? 1 : 0;
}

void hook(bool right, int left) {
	SensorValue[hookRightPiston] = right ? 1 : 0;
	SensorValue[hookLeftPiston] = left ? 1 : 0;
}

task main()
{
	while(true)
	{
		//This updates the variables, which are set to the remote's joystick channels
		joy1X = vexRT[Ch4];
		joy1Y = vexRT[Ch3];
		joy2X = vexRT[Ch1];
		joy2Y = vexRT[Ch2];

		//This gets the angle that the joystick is at
		angle = atan2(-1 * joy1Y, joy1X) * 180 / PI;

		//This gets how far from the center the joystick is positioned
		radius = sqrt((joy1X * joy1X) + (joy1Y * joy1Y));

		//Code for turning
		/*targetAngle += joy2X / 2;
		if(targetAngle > SensorValue(gyro) + 3)
			turn = -1 * abs(joy2X / 2);
	  else if(targetAngle < SensorValue(gyro) - 3)
	  	turn = abs(joy2X / 2);*/

	  //This moves the motors
		motor[rightFrontMotor] = -1 * radius * sinDegrees(angle + 45) + joy2X;//turn;
		motor[rightBackMotor] = -1 * radius * cosDegrees(angle + 45) - joy2X;//turn;
		motor[leftFrontMotor] = -1 * radius * cosDegrees(angle + 45) + joy2X;//turn;
		motor[leftBackMotor] = -1 * radius * sinDegrees(angle + 45) - joy2X;//turn;
		/*'radius * sinDegrees(angle)' is equal to  the value joy1Y of, but without the '+ 45', one of the corners would be the front of the robot. The '+ 45' gives the joystick a 45 degree offset, which makes one of the sides of the robot the front. Similarly, 'radius * cosDegrees(angle)' is equal to joy1X, and the '+ 45' is added for the same reason as above.*/

		//Shooter
		if(vexRT[Btn5U])
			shooter(127);
		else if(vexRT[Btn5D])
			shooter(-127);
		else
			shooter(0);

		//Claw
		if(vexRT[Btn6U])
			claw(true, true);
		else
			claw(false, false);

		//Hook
		if(vexRT[Btn6D])
			hook(true, true);
		else
			hook(false, false);
	}
}
