#pragma config(Sensor, dgtl4,  myEncoderR,     sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  myEncoderL,     sensorQuadEncoder)
#pragma config(Sensor, dgtl1,  limit1,         sensorTouch)
#pragma config(Sensor, dgtl2,  limit2,         sensorTouch)
#pragma config(Sensor, dgtl9,  limit3,         sensorTouch)
#pragma config(Sensor, dgtl10, limit4,         sensorTouch)
#pragma config(Sensor, dgtl11, red,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, yellow,           sensorLEDtoVCC)
#pragma config(Motor,  port2,           leftLift,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           rightLift,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           rightSideMotors, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           leftSideMotors, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           shooter1,      tmotorVex393_MC29, openLoop)//LEFT
#pragma config(Motor,  port7,           shooter2,      tmotorVex393_MC29, openLoop)//LEFT
#pragma config(Motor,  port8,           shooter3,      tmotorVex393_MC29, openLoop)//RIGHT
#pragma config(Motor,  port9,           shooter4,      tmotorVex393_MC29, openLoop)//RIGHT
#pragma config(Motor,  port10,          collector1,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port1,          collector2,     tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(3600)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "PID_Tasks.c" 	//PID Tasks...do not modify!

int shooterVar = 0;
int joy_x1;            // will hold the Y value of the right analog stick
int joy_x2;           // will hold the Y value of the left analog stick
int var1 = 0;
int var2 = 0;

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
/*void startShooter(int speed) {
motor[shooter1] = speed + shooterVar;
motor[shooter2] = speed + shooterVar;
motor[shooter3] = speed + shooterVar;
motor[shooter4] = speed + shooterVar;
EndTimeSlice();
}*/

//Defines PID variables
void PID(int p, int i, int d){
	float  pid_KpL = p;
	float  pid_KiL = i;
	float  pid_KdL = d;
	float  pid_KpR = p;
	float  pid_KiR = i;
	float  pid_KdR = d;
}

//Updates the PID target value during 15 second autonomous
task pidRequested() {
	while(true) {
		wait1Msec(100);
		pidRequestedValue = pidRequestedValue + pidDelta;
	}
}

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	//Reset encoders
	SensorValue[ PID_SENSOR_INDEXR ] = 0;
	SensorValue[ PID_SENSOR_INDEXL ] = 0;
	pidRequestedValue = 0;
	//Set PID variables to 0.37, 0.005, and 0.01 respectively
	PID(0.37, 0.005, 0.01);
	pidDelta = 31.5;
	//Starts PID tasks
	pidRunning = 1;
	startTask( pidControllerL );
	startTask( pidControllerR );
	startTask( pidRequested );
	//Controls when the balls shoot
	wait1Msec(4300);
	motor[collector1] = 127;
	motor[collector2] = -127;
	wait1Msec(750);
	motor[collector1] = 0;
	motor[collector2] = 0;
	wait1Msec(3450);
	motor[collector1] = 127;
	motor[collector2] = -127;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	//Starts PID tasks
	startTask( pidControllerL );
	startTask( pidControllerR );
	//After autonomous, the shooter turns on and doesn't slow down. This fixes it by turning it off then on then off again
	pidRunning = 0;
	pidRunning = 1;
	pidRunning = 0;
	// User control code here, inside the loop
	while (true)
	{
		joy_x1 = vexRT[Ch2Xmtr2];   // This is the RIGHT analog stick y value.
		joy_x2 = vexRT[Ch3Xmtr2];   // This is the LEFT analog stick y value.
		//Base controls
		//Right side of the robot is controlled by the right joystick
		motor[rightSideMotors] = vexRT[Ch3];
		//Left side of the robot is controlled by the left joystick
		motor[leftSideMotors] = vexRT[Ch2];

		//Collector
		if(abs(joy_x1) > 20) {
			motor[collector1] = -127 * (joy_x1 / abs(joy_x1));
			} else {
			motor[collector1] = 0;
		}
		if(abs(joy_x2) > 20) {
			motor[collector2] = 127 * (joy_x2 / abs(joy_x2));
			} else {
			motor[collector2] = 0;
		}

		//Lift
		if(vexRT[Btn6U] == 1) //If button 6U is pressed, activate left lift to go up
		{
			motor[rightLift] = 127;
		}
		else if(vexRT[Btn6D] == 1) //Else if button 6D is pressed, activate left lift to go down
		{
			motor[rightLift] = -127;
		}
		else //If button 6U or button 6D are not pressed, deactivate left lift
		{
			motor[rightLift] = 0;
		}
		if(vexRT[Btn5U] == 1) //If button 5U is pressed, activate right lift to go up
		{
			motor[leftLift] = 127;
		}
		else if(vexRT[Btn5D] == 1) //Else if button 5D is pressed, activate right lift to go down
		{
			motor[leftLift] = -127;
		}
		else //If button 5U or button 5D are not pressed, deactivate right lift
		{
			motor[leftLift] = 0;
		}

		//Starts and stops PID loop with buttons 6U (on) and 6D (off)
		if(vexRT[Btn6UXmtr2] == 1) {
			pidRunning = 1;
			} else if(VexRT[Btn6DXmtr2] == 1) {
			pidRunning = 0;
		}

		//Sets deltas and PID variables
		if(pidRunning == 1) {
			//Used for debugging
			/*lPrevious = SensorValue[ PID_SENSOR_INDEXL ];
			rPrevious = SensorValue[ PID_SENSOR_INDEXR ];
			wait1Msec(50);
			MotorSpeedL = (SensorValue[ PID_SENSOR_INDEXL ] - lPrevious);
			MotorSpeedR = (SensorValue[ PID_SENSOR_INDEXR ] - rPrevious);*/
			if(vexRT[Btn5UXmtr2] == 1) {
				PID(0.37, 0.005, 0.01);
				pidDelta = 31;
				} else if(vexRT[Btn5DXmtr2] == 1) {
				PID(0.37, 0.005, 0.01);
				pidDelta = 30;
			} /*else if(vexRT[Btn7LXmtr2] == 1) {
			PID(0.37, 0.005, 0.01);
			pidDelta = 32;
				}*/ else {
				PID(0.08, 0.01, 0.02);
				pidDelta = 32;
			}
			pidRequestedValue = pidRequestedValue + pidDelta;
			} else {
			pidDelta = 0;
			SensorValue[ PID_SENSOR_INDEXR ] = 0;
			SensorValue[ PID_SENSOR_INDEXL ] = 0;
			pidRequestedValue = 0;
		}

		//Controls LEDs on the robot that let the driver know when a ball is in the collector
		if(SensorValue(limit3) == 1 || SensorValue(limit4) == 1){clearTimer(T1);turnLEDOn(yellow);}
		if(SensorValue(limit1) == 1 || SensorValue(limit2) == 1){clearTimer(T2);turnLEDOn(red);}
		if(SensorValue(limit3) == 0 && SensorValue(limit4) == 0 && time1[T1] > 1000){turnLEDOff(yellow);}
		if(SensorValue(limit1) == 0 && SensorValue(limit2) == 0 && time1[T2] > 1000){turnLEDOff(red);}
		UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
	}
}
